\documentclass{article}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{amsmath,amsfonts,amssymb,graphicx}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegray}{gray}{0.9}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{darkblue}{rgb}{0,0,0.6}
\lstdefinelanguage{SQL}{
  keywords={SELECT, FROM, WHERE, JOIN, ON, AS, GROUP, BY, ORDER, HAVING, INSERT, INTO, UPDATE, DELETE, CREATE, TABLE, DROP, ALTER, ADD, PRIMARY, FOREIGN, KEY, CONSTRAINT, CHECK, DEFAULT, UNION, ALL, DISTINCT, WITH, RECURSIVE, LIMIT, DESC, ASC},
  keywordstyle=\color{darkblue}\bfseries,
  morekeywords={[2]{COUNT, SUM, AVG, MIN, MAX}},
  keywordstyle={[2]\color{darkgreen}\bfseries},
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{--},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\itshape,
  stringstyle=\color{red},
  morestring=[b]',
  morestring=[b]"
}

\lstset{
  language=SQL,
  backgroundcolor=\color{codegray},
  basicstyle=\ttfamily\footnotesize,
  columns=fullflexible,
  breaklines=true,
  keepspaces=true,
  showstringspaces=false,
  frame=single,
  rulecolor=\color{black}
}

\usepackage{forest}
\forestset{
  default preamble={
    for tree={
      draw,
      rounded corners,
      align=center,
      top color=white,
      bottom color=blue!10,
      edge={->,>=latex},
      parent anchor=south,
      child anchor=north,
      grow'=south
    }
  }
}


\title{\textbf{CS 348 Winter 2025: Assignment 3 - Part I}}
\author{Jiaze Xiao \\ 20933691}
\date{\today}
\setlength{\parindent}{0pt}
\begin{document}

\maketitle

\section*{Question 1}
\subsection*{(a)}
The query is a selection query that requires scanning the entire table. While increaing memory does not improve I/O, Option (1) still can't avoid scanning the entire table (no index), so every block still must be read. For Option (2), it reduces the time per I/O operation, meaning we scan the same number of blocks faster. As a result, Option (2) is more effective.
\subsection*{(b)}
Due to the \texttt{ORDER BY} query, sorting is required, and we have no index, so external sorting is needed. Given the I/O cost analysis from course slides:
$$
  \text{Total I/O} = 2B(R)\cdot\left(1+\left\lceil\log_{M-1}\left\lceil\dfrac{B(R)}{M}\right\rceil\right\rceil\right)
$$

For Option (1),
\begin{itemize}
  \item Case 1: $M=101$
        $$\text{Total I/O} = 2000000\cdot\left(1+\left\lceil\log_{100}\left\lceil\dfrac{1000000}{101}\right\rceil\right\rceil\right)=6000000$$
  \item Case 1: $M=1001$
        $$\text{Total I/O} = 2000000\cdot\left(1+\left\lceil\log_{1000}\left\lceil\dfrac{1000000}{1001}\right\rceil\right\rceil\right)=4000000$$
\end{itemize}
We have 33\% speed-up which is greater than 10\% of Option (2). As a result, Option (1) is more effective.

\newpage
\section*{Question 2}
\subsection*{(a)}
\begin{figure}[h!]
  \centering
  \begin{forest}
    [$\pi_{\text{title, author}}$
      [$\bowtie_{\text{Book.bookID = Order.bookID}}$
          [$\sigma_{\text{author LIKE ``\%Kondo''}}$
              [$\pi_{\text{title, author, bookID}}$(Book)]]
            [$\pi_{\text{bookID}}$
              [$\bowtie_{\text{Cust.custID = Order.custID}}$
                  [$\pi_{\text{custID}}$
                      [$\sigma_{\text{state = ``NC''}}$[$\pi_{\text{state, custID}}$(Cust)]]
                    ]
                    [$\pi_{\text{custID, bookID}}$
                      [$\sigma_{\text{shipDate} > :\text{today} - 60}$
                          [$\pi_{\text{shipDate, custID, bookID}}$(Order)]]
                    ]
                ]
            ]
        ]
    ]
  \end{forest}
  \caption{Relational algebra expression tree for Question 2(a)}
\end{figure}

\newpage
\subsection*{(b)}
Plan:
\begin{itemize}
  \item Scan all of Order to apply selection: 6{,}000 I/Os
  \item Filter Order: $60{,}000 / 1{,}000 = 60$ tuples $\Rightarrow$ 6 blocks.
  \item Use improved Block Nested Loop Join with 6 blocks of filtered Order as outer and Inventory as inner:
        $$
          \text{I/O cost of BNLJ} = B(R)+\left\lceil\dfrac{B(R)}{M-2}\right\rceil \cdot B(S) = 6 + 4{,}000
        $$
        The first $B(R)$ can be ignored if we pin the selected 6 blocks from Order in memory.
  \item Output the join result: $60\times 40{,}000/2{,}000=120$
  \item Thus,
        $$
          \boxed{
            \text{Total I/O cost} = 10{,}000 + 6 (\text{if the selected blocks not pinned}) + 120(\text{if we count output})}
        $$
\end{itemize}

\subsection*{(c)}
Plan:
\begin{itemize}
  \item The index on Order(orderID) does not help the selection, because shipDate is not the indexing attribute. We still must scan all 6{,}000 blocks of Order
  \item Scan Order to get 60 matching tuples (6 blocks).
  \item Inventory has 40,000 rows, so 4,000 leaf pages (10 rows per leaf).

        The B$^+$-tree has maximum fan-out = 100, with all levels full except perhaps the root.

        Level 1: Root node

        Level 2: Up to 100 children

        Level 3: Up to $100\times100=10,000$ leaves, which is more than enough to store 4,000 leaf pages.

        So the tree height is 3 (root → internal node → leaf).
  \item For each tuple selected from Order, use the clustered B$^+$-tree index on Inventory to lookup by bookID, with an estimate of 40{,}000/2{,}000=20 matching tuples, so 2 leaf pages.
  \item Cost of an index-lookup = root + internal + 2 leaf pages $\Rightarrow$ 4 I/Os per lookup $\Rightarrow$ 240 I/Os in total.
  \item Same 120 output I/Os
  \item Thus,
        $$
          \boxed{
            \text{Total I/O cost} = 6{,}240 + 6 (\text{if the selected blocks not pinned}) + 120(\text{if we count output})}
        $$
\end{itemize}

\newpage
\section*{Question 3}
The difference between the two plans without any assumption:
\begin{itemize}
  \item Plan 1 returns each row once if there is at least one matching row in T2. Multiple matching T2 rows do not cause duplicates: T1 is either included once or not at all.
  \item Plan 2 returns one copy of T1 for every matching row in T2. If a single T1 row has multiple matches in T2, it appears multiple times in the result.
\end{itemize}

\subsection*{(a)}
\textbf{Answer: False (F)}

\leavevmode\\
Even if $X$ is the PK of $T1$, there is no guarantee that $T2$ will have at most one row matching a particular $T1.X$. $T2$ could still contain many rows with the same $W$ value. In Plan 1, you would return each matching $T1$ row once. In Plan 2, you would return multiple duplicates of that $T1$ row if $T2$ has multiple matches, thus yielding a different (larger) multiset of rows in the output.

\newpage
\subsection*{(b)}
\textbf{Answer: True (T)}

\leavevmode\\
If $W$ is the PK of $T2$, then there is at most one row in $T2$ having a particular $W$ value. That means each row in $T1$ can match  at most one  row in $T2$. Thus:

\begin{itemize}
  \item In Plan 1, if a given $T1$ row finds a matching $T2$ row, we output that $T1$ row once.
  \item In Plan 2, that $T1$ row also matches exactly one $T2$ row, so it appears once.
\end{itemize}

Hence the output rows are the same in both plans.

\subsection*{(c)}
\textbf{Answer: False (F)}

\leavevmode\\
While $T2.W$ being a foreign key to $T1.X$ guarantees that every $T2$ row matches  some  row in $T1$, it  does not  limit how many $T2$ rows can reference the  same  $T1.X$. We could have multiple $T2$ rows referencing the same $T1$ row. In Plan 1, that row in $T1$ would still appear  once  if any $T2$ row exists. In Plan 2, that same $T1$ row appears  as many times  as there are referencing rows in $T2$. Therefore, duplicates can arise in Plan 2, meaning the outputs differ.

\newpage
\section*{Question 4}
\subsection*{(a)}


\newpage
\subsection*{(b)}

\end{document}
